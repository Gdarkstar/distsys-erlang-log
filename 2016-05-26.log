[07:55:11] *** Joins: rakshith (~hehaichi@103.194.14.43)
[08:10:38] <vinayb> hey guys!
[08:18:00] <vinayb> help_me(Animal) ->
[08:18:01] <vinayb> Talk = if Animal == cat  -> "meow";
[08:18:01] <vinayb> Animal == beef -> "mooo";
[08:18:01] <vinayb> Animal == dog  -> "bark";
[08:18:01] <vinayb> Animal == tree -> "bark";
[08:18:03] <vinayb> true -> "fgdadfgna"
[08:18:05] <vinayb> end,
[08:18:07] <vinayb> {Animal, "says " ++ Talk ++ "!"}.
[08:19:16] *** Joins: aditya (3d031604@gateway/web/freenode/ip.61.3.22.4)
[08:19:19] *** Joins: gautham_ (75c671ab@gateway/web/freenode/ip.117.198.113.171)
[08:20:52] *** Quits: rakshith (~hehaichi@103.194.14.43) (Ping timeout: 258 seconds)
[08:21:26] *** Joins: rakshith (67c20e2b@gateway/web/freenode/ip.103.194.14.43)
[08:22:49] *** Joins: rakshith_ (~hehaichi@103.194.14.43)
[08:23:28] *** Parts: rakshith (67c20e2b@gateway/web/freenode/ip.103.194.14.43) ()
[08:23:41] *** Quits: rakshith_ (~hehaichi@103.194.14.43) (Client Quit)
[08:24:00] *** Joins: rakshith (~hehaichi@103.194.14.43)
[08:29:12] *** Quits: aditya (3d031604@gateway/web/freenode/ip.61.3.22.4) (Quit: Page closed)
[08:29:41] *** Joins: aditya_a (3d031604@gateway/web/freenode/ip.61.3.22.4)
[08:31:00] <vinayb> hey guys we'll start in 5 mins
[08:31:47] <vinayb> how's all of yours vacations going? :P
[08:32:51] <rakshith> What's the idea behind assignments? :P
[08:33:16] <vinayb> To get you accustomed to harder assignments to come :P
[08:34:38] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/fEkQJ3'
[08:35:32] <vinayb> okay let's begin
[08:35:37] <vinayb> today's session won't be too long
[08:35:46] <vinayb> So let's come to if expressions
[08:36:04] <vinayb> everybody here knows if statements in C right?
[08:36:16] <rakshith> yeah
[08:36:29] <aditya_a> yes
[08:36:54] <gautham_> yes
[08:37:22] <vinayb> alright. If *expressions* in Erlang are a little different, let's see how
[08:37:28] <vinayb> open up your shell
[08:37:31] <vinayb> and a file
[08:37:39] <vinayb> add this function:
[08:37:52] <vinayb> always_true() -> 
[08:38:02] <vinayb>   if 1 =:= 1 ->
[08:38:06] <vinayb>     works
[08:38:13] <vinayb>   end.
[08:38:42] <vinayb> compile and run it. what's the output?
[08:40:10] *** Joins: salman-bhai (b63a36dd@gateway/web/freenode/ip.182.58.54.221)
[08:40:58] <salman-bhai> Sorry for being late.
[08:41:06] <vinayb> no problem.
[08:41:10] <vinayb> guys, what's the output?
[08:41:27] <rakshith> works
[08:41:35] <vinayb> right!
[08:41:38] <vinayb> now redefine it
[08:41:41] <vinayb> always_works() ->
[08:41:57] <vinayb>   if 1 =:= 2; 1 =:= 1 ->
[08:42:05] <vinayb>     still_works
[08:42:07] <vinayb>   end.
[08:42:15] <vinayb> what's the output?
[08:42:26] <aditya_a> works
[08:42:38] <vinayb> for the second one?
[08:43:03] <aditya_a> yes
[08:43:05] <rakshith> still_works
[08:43:49] <vinayb> correct! everything seems to be working fine, right? if expressions are just like your if statements
[08:43:53] <vinayb> now try this:
[08:43:58] <vinayb> always_fails() ->
[08:44:15] <vinayb>   if 1 =:= 2, 1 =:= 1 ->
[08:44:17] <vinayb>     fails
[08:44:19] <vinayb>   end.
[08:44:25] <vinayb> what's the output?
[08:47:06] <vinayb> anyone?
[08:47:06] <rakshith> I get a warning
[08:47:14] <rakshith> no clause will ever match
[08:47:25] <vinayb> what do you get when you run the function?
[08:47:30] <rakshith> the guard for this clause always evaluated to false
[08:47:47] <rakshith> exception error
[08:48:00] <vinayb> correct! any guesses why that happens?
[08:48:34] <rakshith> there is no else clause?
[08:49:28] <vinayb> alright, remember how i said all expressions in Erlang are supposed to return something? that's true for if expressions too! When no matching clause can be found, it's an error because Erlang doesn't know what the expression should return
[08:49:40] <vinayb> yes rakshith , in Erlang there is no else clause
[08:49:52] <vinayb> so this is how else clauses are made in Erlang:
[08:50:12] <vinayb> maybe_true(N) ->
[08:50:24] <vinayb>   if N =:= 2 -> might_succeed;
[08:50:30] <vinayb>     true -> always_does
[08:50:31] <vinayb>   end.
[08:50:48] <vinayb> see that 'true' clause there? That's effectively the else
[08:51:01] <vinayb> now try running this function
[08:51:25] <vinayb> module_name:maybe_true(2).
[08:51:35] <vinayb> module_name:maybe_true(3).
[08:52:11] <salman-bhai> Vinay I'm getting a syntax error in my first one
[08:52:19] <vinayb> which one?
[08:53:17] <aditya_a> 1)might_succeed  2)always_does
[08:53:34] <salman-bhai> Oh waitt
[08:53:42] <vinayb> correct aditya_a ! so the 'true' clause there acts as else in other languages
[08:54:02] <vinayb> salman-bhai what happened? :P
[08:54:21] <vinayb> right! so now as i said earlier if expressions, just like all expressions in Erlang, have to return something
[08:54:23] *** Joins: akshayrevankar (67157d53@gateway/web/freenode/ip.103.21.125.83)
[08:54:29] <vinayb> now, that can be captured too
[08:54:37] <vinayb> try this function:
[08:54:41] <salman-bhai> 7> c(erlang_module1). erlang_module1.beam: Module name 'erlang_module' does not match file name 'erlang_module1'
[08:55:01] <salman-bhai> error
[08:55:02] <vinayb> animal_sounds(Animal) ->
[08:55:25] <vinayb>   Talk = if Animal == cat -> "meow";
[08:55:45] <vinayb>           Animal == cow -> "mooo";
[08:55:55] <vinayb>         Animal == dog -> "bark";
[08:56:05] <vinayb>           Animal == tree -> "bark";
[08:56:13] <vinayb>       true -> "dsadas"
[08:56:18] <vinayb>       end,
[08:56:33] <vinayb>       {Animal, "says ", ++ Talk ++ "!"}.
[08:56:59] <vinayb> sorry about the atrocious indentation, it's hard to, over IRC :P
[08:57:19] <vinayb> salman-bhai, rename your file to erlang_module1.erl
[08:57:42] <salman-bhai> JUst did
[08:57:51] <salman-bhai> Ohwait
[08:58:11] <vinayb> guys, i want the output to these:
[08:58:46] <vinayb> module_name:animal_sounds(dog).
[08:58:46] <vinayb> module_name:animal_sounds(tree).
[08:58:46] <vinayb> module_name:animal_sounds(nothing).
[08:58:50] <salman-bhai> Wait I'll pm u
[09:00:16] <rakshith> syntax error before ++
[09:00:27] <aditya_a> remove the ,
[09:00:38] <rakshith> ah
[09:01:11] <vinayb> ah yes, nice catch aditya_a ! remove the comma after "says "
[09:02:49] <vinayb> so what are the outputs guys?
[09:02:52] <aditya_a> {dog,"says bark!"}{tree,"says bark!"}{nothing,"says dsadas!"}
[09:03:27] <vinayb> correct! now you've seen how to bind the result of an if expression to a variable, just like it's possible to do with any other expression
[09:04:14] <vinayb> alright, now let's go to case expressions
[09:04:46] <vinayb> case expressions are extremely powerful! 
[09:05:11] <vinayb> you can have complex pattern matching with each argument and have guards on top of it
[09:05:24] <vinayb> let's implement a Set data structure on Lists
[09:05:41] <vinayb> Set is a List where you can't have duplicate members
[09:05:56] <vinayb> let's implement the Insert function:
[09:06:03] <vinayb> insert(X, []) ->
[09:06:09] <vinayb>   [X];
[09:06:17] <vinayb> insert(X, Set) ->
[09:06:25] <vinayb>   case lists:member(X, Set) of 
[09:06:32] <vinayb>     true -> Set;
[09:06:40] <vinayb>     false -> [X|Set]
[09:06:43] <vinayb>   end.
[09:07:49] <vinayb> before we proceed, tell me what do the first two lines do?
[09:09:10] <aditya_a> for an empty list we get a list  with only X
[09:09:14] <rakshith> insert the element into the list and then call the same function with X and Set?
[09:10:05] <vinayb> correct aditya_a! The first two lines pattern match with an empty set, where we return a List with just that element
[09:10:13] <rakshith> and then if X is a member of set ,return the set else append X and then return?
[09:10:33] <vinayb> correct rakshith !
[09:10:42] <vinayb> you can try it out:
[09:10:49] <vinayb> module_name:insert(1, []).
[09:11:11] <vinayb> module_name:insert(5, [1,2,3,4]).
[09:11:21] <vinayb> module_name:insert(9, [1,2,3,4,9]).
[09:11:25] <vinayb> what are the outputs/
[09:11:26] <vinayb> *?
[09:12:10] <aditya_a> [1][1,2,3,4,5][1,2,3,4,9]
[09:12:16] <vinayb> btw lists:member/2 is a function defined in lists module which checks if an element exists in a List
[09:12:45] <vinayb> correct aditya_a ! so as you can see in the last output, an additional 9 did not get added to the List
[09:12:46] <aditya_a> *[1,2,3,4] for second one!
[09:13:12] <vinayb> are you sure? ;)
[09:13:26] <rakshith> How is it arranging itself aditya_a? :P
[09:13:34] <rakshith> [5,1,2,3,4]
[09:13:44] <vinayb> the output to second one is [5,1,2,3,4] as rakshith said
[09:13:59] <vinayb> because we append it to the beginning in the line false -> [x|Set]
[09:14:04] <vinayb> remember your pattern matching guys!
[09:14:22] <vinayb> *[X|Set]
[09:15:06] <vinayb> so that's the syntax of case...of expressions
[09:15:21] <vinayb> case <expr> of
[09:15:29] <vinayb>   clause1 ...
[09:15:35] <vinayb>   clause2 ...
[09:15:38] <vinayb>   ...
[09:15:44] <vinayb>   clausen ...
[09:15:51] <vinayb>  end.
[09:16:12] <vinayb> and remember your clauses can have guards too!
[09:17:03] <vinayb> let's see how we can combine them:
[09:17:16] <vinayb> beach(Temperature) ->
[09:17:23] <vinayb>   case Temperature of 
[09:17:38] <vinayb>     {celcius, N} when N >= 20, N =< 45 ->
[09:17:49] <vinayb>       'favourable';
[09:18:12] <vinayb>     {kelvin, N} when N >= 293, N =< 318 ->
[09:18:22] <vinayb>       'scientifically favourable';
[09:18:41] <vinayb>     {fahrenheit, N} when N >= 68, N =< 113 ->
[09:18:59] <vinayb>       'favourable in imperial countries';
[09:19:09] <vinayb>     _ -> 
[09:19:16] <vinayb>       'avoid beach'
[09:19:20] <vinayb>   end.
[09:20:22] <vinayb> what's the output to these?:
[09:20:41] <vinayb> beach({celcius, 30}).
[09:20:56] <vinayb> beach({kelvin, 300}).
