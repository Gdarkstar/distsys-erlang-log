[03:37:18] *** Quits: kbhat (~kbhat@ec2-52-88-50-237.us-west-2.compute.amazonaws.com) (Ping timeout: 272 seconds)
[03:37:55] *** Joins: kbhat (~kbhat@ec2-52-88-50-237.us-west-2.compute.amazonaws.com)
[11:17:53] *** Joins: rakshith (~hehaichi@117.216.132.196)
[11:26:19] <vinayb> we'll start in 10 mins or so
[11:29:15] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/364pmd'
[11:29:36] *** Joins: aditya (75d8ec5c@gateway/web/freenode/ip.117.216.236.92)
[11:32:35] <vinayb> we'll wait for 5 mins for others to join
[11:34:19] *** Joins: vilas_m (2befa942@gateway/web/freenode/ip.43.239.169.66)
[11:37:12] <vinayb> Alright, we'll start now
[11:37:33] <vinayb> So today we are going to be starting off with concurrency in detail in Erlang
[11:37:52] <vinayb> We have covered the functional aspects and you know to play around with it
[11:38:02] <vinayb> Now we'll see the concurrent aspects
[11:38:30] <vinayb> and we'll also go over a bit of history of Erlang, to see why the things are implemented or designed the way they are
[11:38:46] <vinayb> by the way, before we proceed, any doubts from ANY of the previous sessions?
[11:39:05] <vilas_m> No
[11:39:09] <aditya> no
[11:40:34] *** Joins: gautham_ (673c46b7@gateway/web/freenode/ip.103.60.70.183)
[11:40:37] <vinayb> Okay, so our discipline -- Programming -- or Computer Science, for that matter, has always wondered how to go about running things at the same time in a program
[11:41:17] <vinayb> The most widely used approach is either shared memory based or message passing based. Does anyone here have an idea of what shared memory approach might be?
[11:41:33] <vilas_m> Nope.
[11:42:04] <vinayb> okay, so the shared memory approach is one where we define a small region of code as a "critical section"
[11:42:09] *** Joins: akshayrevankar (67157d53@gateway/web/freenode/ip.103.21.125.83)
[11:42:40] <vinayb> that region of code is code that accesses memory that is SHARED between various different threads / processes
[11:43:12] <vinayb> for eg, you might have a variable x which both threads in a program try to access at one point. that is a critical section
[11:43:28] <vinayb> so that critical section is surrounded by a software lock
[11:43:48] <vinayb> by using this lock, only one thread can go over the critical section area at a time
[11:43:57] <vinayb> so this is the shared memory approach
[11:44:40] <vinayb> but these usually lead to bugs which are very hard to debug. 
[11:44:50] <vinayb> can anyone guess why that might be so?
[11:46:25] <vinayb> okay, so basically it can lead to what we call "race conditions"
[11:46:46] <vinayb> basically, bugs where due to the order of which thread goes, some bug happens
[11:47:10] <vinayb> so it is pretty hard to debug these systems
[11:47:38] <vinayb> Erlang however, uses the message passing approach
[11:48:23] <vinayb> in the message passing approach, there is no shared memory-- threads or processes have their own memory, which cannot be accessed by any other thread / process
[11:48:37] <vinayb> only way of synchronization or communication is through sending messages
[11:49:35] <vinayb> Erlang inherited this approach from PLEX, a language created earlier at Ericsson, for a telecom switch developed with it
[11:50:16] <vinayb> so let's see what the goals for Erlang were (and you can actually see how from those goals, WHY exactly Erlang is used for WhatsApp and Facebook messenger):
[11:50:30] <vinayb> The main ones were being able to scale up and support many thousands of users across many switches, and then to achieve high reliabilityâ€”to the point of never stopping the code.
[11:51:01] <vinayb> any doubts?
[11:51:18] <vilas_m> No
[11:51:28] <aditya> nope
[11:51:29] <gautham_> no
[11:51:48] <rakshith> no
[11:51:57] <vinayb> okay, so the two main goals for Erlang: Scalability, Fault-tolerance
[11:52:08] <vinayb> let's focus on them for a bit
[11:52:17] <vinayb> i'll focus on scaling first
[11:53:26] <vinayb> so in the telecom system, users would be represented as processes which only reacted upon certain events 
[11:53:42] <vinayb> ie, receiving a call, hanging up, etc
[11:54:08] <vinayb> so an ideal system would support processes doing small computations, switching between them very quickly as events came through
[11:54:51] <vinayb> to make it efficient, it made sense for processes to be started very quickly, to be destroyed very quickly and to be able to switch them very fast
[11:55:08] <vinayb> having them lightweight was mandatory to achieve this
[11:55:26] <vinayb> it was also mandatory because you didn't want to have things like process pools (a fixed amount of processes you split the work between.)
[11:55:44] <vinayb> instead, it would be much easier to design programs that could use as many processes as they need.
[11:56:30] <vinayb> another important aspect of scalability is to be able to bypass your hardware
[11:56:39] <vinayb> or hardware's limitations rather
[11:56:54] <vinayb> you can either make hardware better, or add more hardware
[11:57:28] <vinayb> as you might have heard, Moore's law is kinda about to fail... so don't expect cheap better hardware anytime soon. So only option is to add more hardware
[11:57:46] <vinayb> This is where distribution is so useful
[11:58:25] <vinayb> so because telephony applications needed a lot of reliability, it was decided that the cleanest way to do things was to forbid processes from sharing memory
[11:58:55] <vinayb> instead, processes should communicate by sending messages where all the data is copied
[11:59:07] <vinayb> a little slower, but MUCH MUCH sager
[11:59:10] <vinayb> *safer
[11:59:21] <rakshith> and also resource intensive?
[11:59:32] <vinayb> now let's talk a bit about fault-tolerance
[11:59:59] <vinayb> yes rakshith, that too. But then again, that's very much dependent of how the implementation is done
[12:00:04] <vinayb> any doubts?
[12:00:10] <rakshith> no
[12:00:16] <aditya> no
[12:00:20] <vilas_m> no
[12:00:27] <gautham_> no
[12:01:07] <vinayb> the first writers of erlang always kept in mind that failure is common
[12:01:28] <vinayb> you can try to prevent bugs all you want, but most of the time some of them will still happen
[12:01:44] <vinayb> and other than software bugs, there can be hardware failures too
[12:02:25] <vinayb> the idea is thus to find good ways to handle errors and problems than trying to prevent them all
[12:03:53] <vinayb> so the design of having lightweight processes where it is trivial to shutdown and start processes
