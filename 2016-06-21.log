[03:37:18] *** Quits: kbhat (~kbhat@ec2-52-88-50-237.us-west-2.compute.amazonaws.com) (Ping timeout: 272 seconds)
[03:37:55] *** Joins: kbhat (~kbhat@ec2-52-88-50-237.us-west-2.compute.amazonaws.com)
[11:17:53] *** Joins: rakshith (~hehaichi@117.216.132.196)
[11:26:19] <vinayb> we'll start in 10 mins or so
[11:29:15] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/364pmd'
[11:29:36] *** Joins: aditya (75d8ec5c@gateway/web/freenode/ip.117.216.236.92)
[11:32:35] <vinayb> we'll wait for 5 mins for others to join
[11:34:19] *** Joins: vilas_m (2befa942@gateway/web/freenode/ip.43.239.169.66)
[11:37:12] <vinayb> Alright, we'll start now
[11:37:33] <vinayb> So today we are going to be starting off with concurrency in detail in Erlang
[11:37:52] <vinayb> We have covered the functional aspects and you know to play around with it
[11:38:02] <vinayb> Now we'll see the concurrent aspects
[11:38:30] <vinayb> and we'll also go over a bit of history of Erlang, to see why the things are implemented or designed the way they are
[11:38:46] <vinayb> by the way, before we proceed, any doubts from ANY of the previous sessions?
[11:39:05] <vilas_m> No
[11:39:09] <aditya> no
[11:40:34] *** Joins: gautham_ (673c46b7@gateway/web/freenode/ip.103.60.70.183)
[11:40:37] <vinayb> Okay, so our discipline -- Programming -- or Computer Science, for that matter, has always wondered how to go about running things at the same time in a program
[11:41:17] <vinayb> The most widely used approach is either shared memory based or message passing based. Does anyone here have an idea of what shared memory approach might be?
[11:41:33] <vilas_m> Nope.
[11:42:04] <vinayb> okay, so the shared memory approach is one where we define a small region of code as a "critical section"
[11:42:09] *** Joins: akshayrevankar (67157d53@gateway/web/freenode/ip.103.21.125.83)
[11:42:40] <vinayb> that region of code is code that accesses memory that is SHARED between various different threads / processes
[11:43:12] <vinayb> for eg, you might have a variable x which both threads in a program try to access at one point. that is a critical section
[11:43:28] <vinayb> so that critical section is surrounded by a software lock
[11:43:48] <vinayb> by using this lock, only one thread can go over the critical section area at a time
[11:43:57] <vinayb> so this is the shared memory approach
[11:44:40] <vinayb> but these usually lead to bugs which are very hard to debug. 
[11:44:50] <vinayb> can anyone guess why that might be so?
[11:46:25] <vinayb> okay, so basically it can lead to what we call "race conditions"
[11:46:46] <vinayb> basically, bugs where due to the order of which thread goes, some bug happens
[11:47:10] <vinayb> so it is pretty hard to debug these systems
[11:47:38] <vinayb> Erlang however, uses the message passing approach
[11:48:23] <vinayb> in the message passing approach, there is no shared memory-- threads or processes have their own memory, which cannot be accessed by any other thread / process
[11:48:37] <vinayb> only way of synchronization or communication is through sending messages
[11:49:35] <vinayb> Erlang inherited this approach from PLEX, a language created earlier at Ericsson, for a telecom switch developed with it
