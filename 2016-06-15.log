[11:19:33] <vinayb> hey folks
[11:22:31] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/FdGIf7'
[11:22:35] *** Joins: rakshith (~hehaichi@103.194.22.43)
[11:27:44] *** Joins: vilas_m (75c6771a@gateway/web/freenode/ip.117.198.119.26)
[11:28:11] *** Joins: aditya_a (~androirc@110-170-29-146.static.asianet.co.th)
[11:31:37] *** Quits: aditya_a (~androirc@110-170-29-146.static.asianet.co.th) (Client Quit)
[11:32:04] *** Joins: aditya_a (~androirc@110-170-29-146.static.asianet.co.th)
[11:32:09] <vinayb> Alright guys, i guess no one else is going to join us. Shall we begin?
[11:32:46] <vilas_m> Yea
[11:32:57] <aditya_a> Yes
[11:33:06] *** Joins: Pratyushgr (31cbcc3d@gateway/web/freenode/ip.49.203.204.61)
[11:33:12] <rakshith> yes
[11:33:23] <vinayb> alright we'll start
[11:34:08] <vinayb> Today we'll talk about the Records data structure in Erlang
[11:34:50] <vinayb> Erlang records are a lot like structs in C
[11:35:21] <vinayb> Pretty useful whenever you have a small data structure where you want to access the attributes by name directly
[11:35:40] <vinayb> Alright, open up a records.erl file
[11:35:43] <vinayb> and type this:
[11:36:01] <vinayb> -module(records).
[11:36:01] <vinayb> -compile(export_all).
[11:36:04] <vinayb> -record(robot, {name, type=industrial, hobbies, details=[]}).
[11:36:40] <vinayb> btw, if you're tired of passing each function signature to the compile attribute, then you can just use export_all
[11:37:01] <vinayb> but, don't do this usually, because it helps prevent small errors
[11:37:38] <vinayb> so a record is declared just as module attributes
[11:37:51] *** Joins: m_gautham (67fd8231@gateway/web/freenode/ip.103.253.130.49)
[11:38:15] <vinayb> in the third line, we just defined a record of the type robot, with fields, name, type, hobbies and details
[11:38:35] <vinayb> and we have given default value of industrial to type and empty list to details
[11:39:06] <vinayb> Please don't confuse yourself when I say "record of the type robot" and has a "field called type"
[11:39:17] <vinayb> any doubts?
[11:39:22] <vilas_m> No
[11:39:40] <vinayb> alright, go ahead and define this function in the same file:
[11:39:52] <vinayb> first_robot() ->
[11:39:53] <vinayb>     #robot{name="Mechatron",
[11:39:53] <vinayb>            type=handmade, 
[11:39:55] <vinayb>            details=["Moved by a small man inside"]}.
[11:40:31] <vinayb> and then run the code
[11:40:34] <vinayb> and call the function
[11:40:41] <vinayb> records:first_robot()
[11:40:44] <vinayb> what's the output?
[11:42:20] <vilas_m> {robot,"Mechatron",handmade,undefined,        ["Moved by a small man inside"]}
[11:42:34] *** Joins: adarsh_h (6ace8120@gateway/web/freenode/ip.106.206.129.32)
[11:42:55] <vinayb> Right! so you can see how the output is like a tuple
[11:43:20] <vinayb> in fact, records are nothing but some additional syntax (what we call syntactic sugar) on top of tuples
[11:43:28] <vinayb> Fortunately, there's a way to make it better
[11:43:46] <vinayb> The Erlang shell has a command rr(Module) that lets you load record definitions from module:
[11:43:56] <vinayb> run this:
[11:43:57] <vinayb> rr(records).
[11:44:04] <vinayb> records:first_robot(). 
[11:44:20] <vinayb> what's the output?
[11:44:54] <vilas_m> #robot{name = "Mechatron",type = handmade,        hobbies = undefined,        details = ["Moved by a small man inside"]}
[11:45:09] <vinayb> right! so here the output explicitly shows us that it is a record
[11:45:42] <vinayb> To see the behavior of the defaults we set in the robot definition, let's compile the following function:
[11:45:58] <vinayb> car_factory(CorpName) -> #robot{name=CorpName, hobbies="building cars"}.
[11:46:39] <vinayb> run it:
[11:46:40] <vinayb> c(records).
[11:46:50] <vinayb> records:car_factory("Jokeswagen").
[11:47:58] <vinayb> what's the output?
[11:48:14] <vilas_m> #robot{name = "Jokeswagen",type = industrial,        hobbies = "building cars",details = []}
[11:48:39] <vinayb> yeah, so you can see that when we didn't specify the type and details, the defaults got used
[11:48:42] *** Quits: m_gautham (67fd8231@gateway/web/freenode/ip.103.253.130.49) (Ping timeout: 250 seconds)
[11:49:03] <vinayb> Writing records alone won't do much. We need a way to extract values from them. There are basically two ways to do this. The first one is with a special 'dot syntax'
[11:49:34] <vinayb> run this:
[11:49:35] <vinayb> Crusher = #robot{name="Crusher", hobbies=["Crushing people","petting cats"]}. 
[11:49:42] <vinayb> in the shell
[11:49:54] <vinayb> Crusher#robot.hobbies.
[11:49:57] <vinayb> what's the output?
[11:51:19] <vilas_m> ["Crushing people","petting cats"]
[11:52:14] <vinayb> right! so you can see how we can extract values from a record. Yes, the syntax is pretty ugly. Even though techincally you shouldn't need to specify the 'robot' keyword, it's just the way it is
[11:52:42] <vinayb> nested records get even uglier:
[11:52:50] <vinayb> NestedBot = #robot{details=#robot{name="erNest"}}.
[11:52:59] <vinayb> (NestedBot#robot.details)#robot.name.
[11:54:09] <vinayb> And yes, the parentheses are mandatory.
[11:54:32] <vinayb> one saving feature of records is the possibility to use them in function heads to pattern match and also in guards 
[11:55:00] <vinayb> declare a new record as follows on top of the file, and then add the functions under:
[11:55:08] <vinayb> -record(user, {id, name, group, age}).
[11:55:16] <vinayb> admin_panel(#user{name=Name, group=admin}) ->
[11:55:16] <vinayb> Name ++ " is allowed!";
[11:55:16] <vinayb> admin_panel(#user{name=Name}) ->
[11:55:17] <vinayb> Name ++ " is not allowed".
[11:56:10] <vinayb> adult_section(U = #user{}) when U#user.age >= 18 -> %% Show stuff that can't be written in such a text allowed;
[11:56:13] <vinayb> adult_section(_) -> %% redirect to pogo website forbidden.
[11:56:30] <vinayb> damn formatting, hold on
[11:56:35] <vinayb> adult_section(U = #user{}) when U#user.age >= 18 ->
[11:56:44] <vinayb>     allowed;
[11:56:49] <vinayb> adult_section(_) ->
[11:56:58] <vinayb>     forbidden.
[11:57:53] <vinayb> so you can see how you can use variables to bind to any field of a record
[11:58:37] <vinayb> you can also bind the entire record to a variable by doing Var = #record{}
[11:58:40] *** Joins: m_gautham (75c67580@gateway/web/freenode/ip.117.198.117.128)
[11:58:48] <vinayb> like in the adult_section definition :P
[11:58:55] *** Parts: m_gautham (75c67580@gateway/web/freenode/ip.117.198.117.128) ()
[11:59:15] <vinayb> alright, load all this up in the shell
[11:59:53] <vinayb> and tell me the output to these expressions:
[12:00:11] <vinayb> don't foget to c(records). and then rr(records).
[12:00:36] <vinayb> records:admin_panel(#user{id=1, name="rohit", group=admin, age=96}).
[12:00:45] <vinayb> records:admin_panel(#user{id=2, name="you", group=users, age=66}).
[12:00:56] *** Joins: m_gautham (75c67580@gateway/web/freenode/ip.117.198.117.128)
[12:01:10] <vinayb> records:adult_section(#user{id=21, name="rahul", group=users, age=72}).
[12:01:32] <vinayb> records:adult_section(#user{id=22, name="akshay", group=users, age=13}).
[12:01:47] <vinayb> give me all the 4 outputs
[12:03:06] *** Quits: rakshith (~hehaichi@103.194.22.43) (Ping timeout: 276 seconds)
[12:05:04] <vilas_m> "rohit is allowed!", "you is not allowed", allowed, forbidden
[12:05:45] <vinayb> right! so you can see the benefits of records over tuples
[12:06:04] <vinayb> . If we were to use a normal tuple, the function definition might need to look a bit like function({record, _, _, ICareAboutThis, _, _}) -> .... 
