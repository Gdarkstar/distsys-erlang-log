[11:19:33] <vinayb> hey folks
[11:22:31] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/FdGIf7'
[11:22:35] *** Joins: rakshith (~hehaichi@103.194.22.43)
[11:27:44] *** Joins: vilas_m (75c6771a@gateway/web/freenode/ip.117.198.119.26)
[11:28:11] *** Joins: aditya_a (~androirc@110-170-29-146.static.asianet.co.th)
[11:31:37] *** Quits: aditya_a (~androirc@110-170-29-146.static.asianet.co.th) (Client Quit)
[11:32:04] *** Joins: aditya_a (~androirc@110-170-29-146.static.asianet.co.th)
[11:32:09] <vinayb> Alright guys, i guess no one else is going to join us. Shall we begin?
[11:32:46] <vilas_m> Yea
[11:32:57] <aditya_a> Yes
[11:33:06] *** Joins: Pratyushgr (31cbcc3d@gateway/web/freenode/ip.49.203.204.61)
[11:33:12] <rakshith> yes
[11:33:23] <vinayb> alright we'll start
[11:34:08] <vinayb> Today we'll talk about the Records data structure in Erlang
[11:34:50] <vinayb> Erlang records are a lot like structs in C
[11:35:21] <vinayb> Pretty useful whenever you have a small data structure where you want to access the attributes by name directly
[11:35:40] <vinayb> Alright, open up a records.erl file
[11:35:43] <vinayb> and type this:
[11:36:01] <vinayb> -module(records).
[11:36:01] <vinayb> -compile(export_all).
[11:36:04] <vinayb> -record(robot, {name, type=industrial, hobbies, details=[]}).
[11:36:40] <vinayb> btw, if you're tired of passing each function signature to the compile attribute, then you can just use export_all
[11:37:01] <vinayb> but, don't do this usually, because it helps prevent small errors
[11:37:38] <vinayb> so a record is declared just as module attributes
[11:37:51] *** Joins: m_gautham (67fd8231@gateway/web/freenode/ip.103.253.130.49)
[11:38:15] <vinayb> in the third line, we just defined a record of the type robot, with fields, name, type, hobbies and details
[11:38:35] <vinayb> and we have given default value of industrial to type and empty list to details
[11:39:06] <vinayb> Please don't confuse yourself when I say "record of the type robot" and has a "field called type"
[11:39:17] <vinayb> any doubts?
[11:39:22] <vilas_m> No
[11:39:40] <vinayb> alright, go ahead and define this function in the same file:
[11:39:52] <vinayb> first_robot() ->
[11:39:53] <vinayb>     #robot{name="Mechatron",
[11:39:53] <vinayb>            type=handmade, 
[11:39:55] <vinayb>            details=["Moved by a small man inside"]}.
[11:40:31] <vinayb> and then run the code
[11:40:34] <vinayb> and call the function
[11:40:41] <vinayb> records:first_robot()
[11:40:44] <vinayb> what's the output?
[11:42:20] <vilas_m> {robot,"Mechatron",handmade,undefined,        ["Moved by a small man inside"]}
[11:42:34] *** Joins: adarsh_h (6ace8120@gateway/web/freenode/ip.106.206.129.32)
[11:42:55] <vinayb> Right! so you can see how the output is like a tuple
[11:43:20] <vinayb> in fact, records are nothing but some additional syntax (what we call syntactic sugar) on top of tuples
[11:43:28] <vinayb> Fortunately, there's a way to make it better
[11:43:46] <vinayb> The Erlang shell has a command rr(Module) that lets you load record definitions from module:
[11:43:56] <vinayb> run this:
[11:43:57] <vinayb> rr(records).
[11:44:04] <vinayb> records:first_robot(). 
[11:44:20] <vinayb> what's the output?
[11:44:54] <vilas_m> #robot{name = "Mechatron",type = handmade,        hobbies = undefined,        details = ["Moved by a small man inside"]}
[11:45:09] <vinayb> right! so here the output explicitly shows us that it is a record
[11:45:42] <vinayb> To see the behavior of the defaults we set in the robot definition, let's compile the following function:
[11:45:58] <vinayb> car_factory(CorpName) -> #robot{name=CorpName, hobbies="building cars"}.
