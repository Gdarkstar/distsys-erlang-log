[10:02:22] *** Joins: salman-bhai (b63a5fb3@gateway/web/freenode/ip.182.58.95.179)
[11:19:50] *** Joins: aditya (75d8ec6f@gateway/web/freenode/ip.117.216.236.111)
[11:21:02] *** Joins: vilas_m (3b5b10ee@gateway/web/freenode/ip.59.91.16.238)
[11:21:46] <vilas_m> Anybody else watching the finals? :P
[11:24:31] *** Joins: akshayrevankar (67157d53@gateway/web/freenode/ip.103.21.125.83)
[11:24:39] <vinayb> hey guys
[11:25:22] <salman-bhai> hey
[11:25:43] <salman-bhai> vilas_m Me! :p
[11:26:21] <vilas_m> Hi ! :)
[11:27:06] <akshayrevankar> ██████╗ ███████╗ ██████╗██╗   ██╗██████╗ ███████╗██╗ ██████╗ ███╗   ██╗
[11:27:16] <vilas_m> Good timing for the session xD Would have switched off the TV anyway :P
[11:27:17] <akshayrevankar> Hey guys
[11:27:32] <salman-bhai> hey akshay
[11:27:49] <aditya> Hi!
[11:27:50] <vilas_m> Hi Akshay Sir :)
[11:28:38] <akshayrevankar> Thanks for being here on a Sunday :D.. Hope you dont mind a 1 hour session :P
[11:28:57] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/GFWbqP'
[11:30:01] <akshayrevankar> We will start the session after 5 minutes..
[11:30:18] <vinayb> call all your friends guys
[11:30:28] <akshayrevankar> So how are vacations going on for all?
[11:30:33] <vinayb> i expect everyone to be here
[11:30:57] <akshayrevankar> vinayb #being strict is it :P
[11:31:42] <vinayb> ;)
[11:35:58] <akshayrevankar> ok guys.. so we will start of with todays session..
[11:36:20] <akshayrevankar> so last time rakshith asked if there exists any looping constructs in erlang..
[11:36:24] *** Joins: adarsh_h (6ace890c@gateway/web/freenode/ip.106.206.137.12)
[11:36:35] <akshayrevankar> as vinay said, there are no looping constructs.. like for or while
[11:36:51] <akshayrevankar> so we make the use of recursion in implementing of loops..
[11:37:17] <akshayrevankar> so can someone recall and list what all you guys coded using recursion in your CO110 course
[11:38:16] <vilas_m> Factorial, binary search, sum upto n, nCr.
[11:38:45] <aditya> fibonacci,sumofdigits
[11:39:16] <vilas_m> X^n
[11:39:20] <akshayrevankar> yes.. you implemented the funtions as you mentioned using recursion.. you were explictly taught some functions using recursion..
[11:39:38] <akshayrevankar> but what are you actually doing there in reality.. can the same function be implemented using a while loop?
[11:40:11] <akshayrevankar> can one of you write down a C like code here for a while loop based factorial and a recursion based
[11:40:31] <akshayrevankar> aditya can write down the C like
[11:40:39] <akshayrevankar> and vilas the recursion based
[11:41:19] <akshayrevankar> I want others to also acknowledge and reply... dont be a spectator only.. If you dont know anything, ask of immediately..
[11:41:34] <aditya> fact=1; while(n){ fact*=n; n--;}
[11:41:55] <vilas_m> int fact (int n) { if(n==1) return 1; else return(n*fact(n-1)); }
[11:43:04] <akshayrevankar> ok.. can someone identify a small correction in code written by vilas..
[11:43:21] <aditya> o factorial!
[11:43:34] <akshayrevankar> correct aditya..
[11:43:47] <akshayrevankar> just a matter of n==0 instead of n==1
[11:44:07] <akshayrevankar> so this condition of n==0 is called the base case for recursion..
[11:44:19] <akshayrevankar> which is when the recursion stops..
[11:44:54] <akshayrevankar> today we will first start by writing a factorial code in erlang..
[11:45:16] *** Joins: m_gautham (75dd6f0f@gateway/web/freenode/ip.117.221.111.15)
[11:45:17] <akshayrevankar> guys make a erl file with module name "recursion"
[11:45:50] <akshayrevankar> gautham, please go through the log :)
[11:46:38] <akshayrevankar> ok, lets write our function for factorial using recursion..
[11:46:56] <akshayrevankar> you know the base case which is fac(0) = 1
[11:47:06] <akshayrevankar> so what would be the equivalent statement in erlang?
[11:48:47] <aditya> fac(0) -> 1;
[11:49:01] <akshayrevankar> yes correct aditya..
[11:49:26] <akshayrevankar> its as simple as that..
[11:49:49] <akshayrevankar> do others have a doubt with regard to that ^^^ ?
[11:50:08] <salman-bhai> No
[11:50:09] <vilas_m> No.
[11:50:39] <akshayrevankar> i want a reply from everyone.. a simple Yes or No
[11:50:40] <salman-bhai> Oh wait shouldn't it be full-stop.
[11:50:53] <salman-bhai> fac(0) -> 1.
[11:51:00] <akshayrevankar> ya correct salman..
[11:51:22] <aditya> It needs to be followed by fac(N)
[11:51:31] <akshayrevankar> aditya "might" have just used the semicolon as our function isnt complete yet
[11:51:42] <akshayrevankar> ya..
[11:52:02] <akshayrevankar> ok..
[11:52:05] <vinayb> exactly akshayrevankar . salman-bhai , the function defintion isn't complete yet
[11:52:13] <salman-bhai> Oh okay
[11:52:31] <akshayrevankar> ya so we have the other half of the function remaining..
[11:52:48] <akshayrevankar> so if  n=/=0 then what do we do?
[11:53:13] <vilas_m> N*fac(N-1).
[11:53:32] <akshayrevankar> correct! we return the above value..
[11:53:41] <akshayrevankar> so what would be the erlang equivalent?
[11:53:50] <aditya> fac(N) when N > 0 -> N*fac(N-1).
[11:53:56] <vilas_m> fac(N) when N >=1 -> N*fac(N-1).
[11:55:22] <akshayrevankar> yes both are correct..
[11:55:42] <akshayrevankar> we can even write fac(N) -> N*fac(N-1).
[11:56:37] <akshayrevankar> but can anyone tell me what should be kept in mind while writing the above statement?
[11:56:47] <salman-bhai> N negative?
[11:56:57] <salman-bhai> It can't be negative
[11:57:06] <vilas_m> It should follow the base case?
[11:57:20] <akshayrevankar> ya.. thats true.. for now we will consider that user is sensible to not input negative :D
[11:57:49] <akshayrevankar> fac(N) -> N*fac(N-1). I wrote this statement without any condition right?
[11:58:02] <salman-bhai> Yes
[11:58:28] <akshayrevankar> if i write this statement above fac(0)->1 , then the function will go into a infinite recursion
[11:58:35] <akshayrevankar> #NOTE
[11:58:52] <akshayrevankar> the pattern matching works in the same order as you write the statement..
[11:59:09] <akshayrevankar> you can consider it to be like a if-elseif ladder..
[11:59:18] <akshayrevankar> Imagine this situation:
[11:59:24] <akshayrevankar> your code is:
[11:59:34] <akshayrevankar> fac(N)->N*fac(N-1);
[11:59:40] <akshayrevankar> fac(0)->1.
[12:00:07] <akshayrevankar> for erlang it is like, first check if its a Number N, if yes execute the first statement..
[12:00:18] <akshayrevankar> elseif N=0 then return 1
[12:00:36] <akshayrevankar> so you notice that the first statement is always true, the second will never get executed.
[12:01:15] <akshayrevankar> so you either do it by giving a condition that fac(N) when N>0
[12:01:16] <akshayrevankar> OR
[12:01:24] <akshayrevankar> you write fac(0)->1;
[12:01:26] <akshayrevankar> and then
[12:01:35] <akshayrevankar> fac(N)->N*fac(N-1);
[12:01:43] <akshayrevankar> can you tell me which way is preferable and why?
[12:02:45] <vilas_m> First one? Lesser number of statements executed?
[12:03:02] <aditya> 1st one lesser comparisons?
[12:03:16] <akshayrevankar> can u write down which..
[12:03:25] <akshayrevankar> its all jumbled up there :D
[12:03:40] <aditya> 2nd
[12:03:57] <akshayrevankar> ok 1st or 2nd :P
[12:04:03] <salman-bhai> 2nd
[12:04:17] <vilas_m> fac(N) when N>0 -> N*fac(N-1) ; fac(0) -> 1.
[12:04:30] <salman-bhai> fac(N)->N*fac(N-1).*
[12:04:38] <akshayrevankar> why would this be preferable @vilas
[12:05:03] <akshayrevankar> dont you think in worst case there will be two pattern match and one condition checking?
[12:05:44] <akshayrevankar> if you do it as fac(0)->1; fac(N)->N*fac(N-1). this would involve two pattern matching..
[12:06:00] <akshayrevankar> so i guess the 2nd one is faster..
[12:06:02] <vilas_m> For every number, if the zero case was first then it would have to be checked each time? I was thinking it could skip checking for 0 if the zero case was later.
[12:06:24] <vilas_m> Oh ok
[12:07:30] <akshayrevankar> ya i agree.. its nearly the same... its just once case where it goes down.. not a big deal here.. doesnt matter to us much.. but when we see further examples, we will understand more about the timing..
[12:08:01] <akshayrevankar> ok so we wrote our first recursion function which was factorial..
[12:08:25] <akshayrevankar> now lets move onto another very simple example which is finding the number of elements in a list..
[12:08:37] <akshayrevankar> can anyone come up with a solution for it..?
[12:09:13] <akshayrevankar> i want adarsh and gautham to reply..
[12:09:34] <akshayrevankar> first start by thinking of the base condition.. what could that be?
[12:10:18] <aditya> length([]) -> 0; I  think?
[12:10:42] <akshayrevankar> yes correct... length of an empty list is 0..
