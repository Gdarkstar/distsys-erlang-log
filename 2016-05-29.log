[10:02:22] *** Joins: salman-bhai (b63a5fb3@gateway/web/freenode/ip.182.58.95.179)
[11:19:50] *** Joins: aditya (75d8ec6f@gateway/web/freenode/ip.117.216.236.111)
[11:21:02] *** Joins: vilas_m (3b5b10ee@gateway/web/freenode/ip.59.91.16.238)
[11:21:46] <vilas_m> Anybody else watching the finals? :P
[11:24:31] *** Joins: akshayrevankar (67157d53@gateway/web/freenode/ip.103.21.125.83)
[11:24:39] <vinayb> hey guys
[11:25:22] <salman-bhai> hey
[11:25:43] <salman-bhai> vilas_m Me! :p
[11:26:21] <vilas_m> Hi ! :)
[11:27:06] <akshayrevankar> ██████╗ ███████╗ ██████╗██╗   ██╗██████╗ ███████╗██╗ ██████╗ ███╗   ██╗
[11:27:16] <vilas_m> Good timing for the session xD Would have switched off the TV anyway :P
[11:27:17] <akshayrevankar> Hey guys
[11:27:32] <salman-bhai> hey akshay
[11:27:49] <aditya> Hi!
[11:27:50] <vilas_m> Hi Akshay Sir :)
[11:28:38] <akshayrevankar> Thanks for being here on a Sunday :D.. Hope you dont mind a 1 hour session :P
[11:28:57] *** vinayb changes topic to 'Distributed Systems Programming with Erlang | Today's log: https://goo.gl/GFWbqP'
[11:30:01] <akshayrevankar> We will start the session after 5 minutes..
[11:30:18] <vinayb> call all your friends guys
[11:30:28] <akshayrevankar> So how are vacations going on for all?
[11:30:33] <vinayb> i expect everyone to be here
[11:30:57] <akshayrevankar> vinayb #being strict is it :P
[11:31:42] <vinayb> ;)
[11:35:58] <akshayrevankar> ok guys.. so we will start of with todays session..
[11:36:20] <akshayrevankar> so last time rakshith asked if there exists any looping constructs in erlang..
[11:36:24] *** Joins: adarsh_h (6ace890c@gateway/web/freenode/ip.106.206.137.12)
[11:36:35] <akshayrevankar> as vinay said, there are no looping constructs.. like for or while
[11:36:51] <akshayrevankar> so we make the use of recursion in implementing of loops..
[11:37:17] <akshayrevankar> so can someone recall and list what all you guys coded using recursion in your CO110 course
[11:38:16] <vilas_m> Factorial, binary search, sum upto n, nCr.
[11:38:45] <aditya> fibonacci,sumofdigits
[11:39:16] <vilas_m> X^n
[11:39:20] <akshayrevankar> yes.. you implemented the funtions as you mentioned using recursion.. you were explictly taught some functions using recursion..
[11:39:38] <akshayrevankar> but what are you actually doing there in reality.. can the same function be implemented using a while loop?
[11:40:11] <akshayrevankar> can one of you write down a C like code here for a while loop based factorial and a recursion based
[11:40:31] <akshayrevankar> aditya can write down the C like
[11:40:39] <akshayrevankar> and vilas the recursion based
[11:41:19] <akshayrevankar> I want others to also acknowledge and reply... dont be a spectator only.. If you dont know anything, ask of immediately..
[11:41:34] <aditya> fact=1; while(n){ fact*=n; n--;}
[11:41:55] <vilas_m> int fact (int n) { if(n==1) return 1; else return(n*fact(n-1)); }
[11:43:04] <akshayrevankar> ok.. can someone identify a small correction in code written by vilas..
[11:43:21] <aditya> o factorial!
[11:43:34] <akshayrevankar> correct aditya..
[11:43:47] <akshayrevankar> just a matter of n==0 instead of n==1
[11:44:07] <akshayrevankar> so this condition of n==0 is called the base case for recursion..
[11:44:19] <akshayrevankar> which is when the recursion stops..
[11:44:54] <akshayrevankar> today we will first start by writing a factorial code in erlang..
[11:45:16] *** Joins: m_gautham (75dd6f0f@gateway/web/freenode/ip.117.221.111.15)
[11:45:17] <akshayrevankar> guys make a erl file with module name "recursion"
[11:45:50] <akshayrevankar> gautham, please go through the log :)
[11:46:38] <akshayrevankar> ok, lets write our function for factorial using recursion..
[11:46:56] <akshayrevankar> you know the base case which is fac(0) = 1
[11:47:06] <akshayrevankar> so what would be the equivalent statement in erlang?
[11:48:47] <aditya> fac(0) -> 1;
[11:49:01] <akshayrevankar> yes correct aditya..
[11:49:26] <akshayrevankar> its as simple as that..
[11:49:49] <akshayrevankar> do others have a doubt with regard to that ^^^ ?
[11:50:08] <salman-bhai> No
[11:50:09] <vilas_m> No.
[11:50:39] <akshayrevankar> i want a reply from everyone.. a simple Yes or No
[11:50:40] <salman-bhai> Oh wait shouldn't it be full-stop.
[11:50:53] <salman-bhai> fac(0) -> 1.
[11:51:00] <akshayrevankar> ya correct salman..
[11:51:22] <aditya> It needs to be followed by fac(N)
[11:51:31] <akshayrevankar> aditya "might" have just used the semicolon as our function isnt complete yet
[11:51:42] <akshayrevankar> ya..
[11:52:02] <akshayrevankar> ok..
[11:52:05] <vinayb> exactly akshayrevankar . salman-bhai , the function defintion isn't complete yet
[11:52:13] <salman-bhai> Oh okay
[11:52:31] <akshayrevankar> ya so we have the other half of the function remaining..
[11:52:48] <akshayrevankar> so if  n=/=0 then what do we do?
[11:53:13] <vilas_m> N*fac(N-1).
[11:53:32] <akshayrevankar> correct! we return the above value..
[11:53:41] <akshayrevankar> so what would be the erlang equivalent?
[11:53:50] <aditya> fac(N) when N > 0 -> N*fac(N-1).
[11:53:56] <vilas_m> fac(N) when N >=1 -> N*fac(N-1).
[11:55:22] <akshayrevankar> yes both are correct..
[11:55:42] <akshayrevankar> we can even write fac(N) -> N*fac(N-1).
[11:56:37] <akshayrevankar> but can anyone tell me what should be kept in mind while writing the above statement?
[11:56:47] <salman-bhai> N negative?
[11:56:57] <salman-bhai> It can't be negative
[11:57:06] <vilas_m> It should follow the base case?
[11:57:20] <akshayrevankar> ya.. thats true.. for now we will consider that user is sensible to not input negative :D
[11:57:49] <akshayrevankar> fac(N) -> N*fac(N-1). I wrote this statement without any condition right?
[11:58:02] <salman-bhai> Yes
[11:58:28] <akshayrevankar> if i write this statement above fac(0)->1 , then the function will go into a infinite recursion
[11:58:35] <akshayrevankar> #NOTE
[11:58:52] <akshayrevankar> the pattern matching works in the same order as you write the statement..
[11:59:09] <akshayrevankar> you can consider it to be like a if-elseif ladder..
[11:59:18] <akshayrevankar> Imagine this situation:
[11:59:24] <akshayrevankar> your code is:
[11:59:34] <akshayrevankar> fac(N)->N*fac(N-1);
[11:59:40] <akshayrevankar> fac(0)->1.
[12:00:07] <akshayrevankar> for erlang it is like, first check if its a Number N, if yes execute the first statement..
[12:00:18] <akshayrevankar> elseif N=0 then return 1
[12:00:36] <akshayrevankar> so you notice that the first statement is always true, the second will never get executed.
[12:01:15] <akshayrevankar> so you either do it by giving a condition that fac(N) when N>0
[12:01:16] <akshayrevankar> OR
[12:01:24] <akshayrevankar> you write fac(0)->1;
[12:01:26] <akshayrevankar> and then
[12:01:35] <akshayrevankar> fac(N)->N*fac(N-1);
[12:01:43] <akshayrevankar> can you tell me which way is preferable and why?
[12:02:45] <vilas_m> First one? Lesser number of statements executed?
[12:03:02] <aditya> 1st one lesser comparisons?
[12:03:16] <akshayrevankar> can u write down which..
[12:03:25] <akshayrevankar> its all jumbled up there :D
[12:03:40] <aditya> 2nd
[12:03:57] <akshayrevankar> ok 1st or 2nd :P
[12:04:03] <salman-bhai> 2nd
[12:04:17] <vilas_m> fac(N) when N>0 -> N*fac(N-1) ; fac(0) -> 1.
[12:04:30] <salman-bhai> fac(N)->N*fac(N-1).*
[12:04:38] <akshayrevankar> why would this be preferable @vilas
[12:05:03] <akshayrevankar> dont you think in worst case there will be two pattern match and one condition checking?
[12:05:44] <akshayrevankar> if you do it as fac(0)->1; fac(N)->N*fac(N-1). this would involve two pattern matching..
[12:06:00] <akshayrevankar> so i guess the 2nd one is faster..
[12:06:02] <vilas_m> For every number, if the zero case was first then it would have to be checked each time? I was thinking it could skip checking for 0 if the zero case was later.
[12:06:24] <vilas_m> Oh ok
[12:07:30] <akshayrevankar> ya i agree.. its nearly the same... its just once case where it goes down.. not a big deal here.. doesnt matter to us much.. but when we see further examples, we will understand more about the timing..
[12:08:01] <akshayrevankar> ok so we wrote our first recursion function which was factorial..
[12:08:25] <akshayrevankar> now lets move onto another very simple example which is finding the number of elements in a list..
[12:08:37] <akshayrevankar> can anyone come up with a solution for it..?
[12:09:13] <akshayrevankar> i want adarsh and gautham to reply..
[12:09:34] <akshayrevankar> first start by thinking of the base condition.. what could that be?
[12:10:18] <aditya> length([]) -> 0; I  think?
[12:10:42] <akshayrevankar> yes correct... length of an empty list is 0..
[12:11:01] <akshayrevankar> does everyone agree to it?
[12:11:16] <vilas_m> Yup
[12:11:44] <akshayrevankar> like did u guys understand how we got the base condition.. recursion is all about firstly finding the base condition and then moving up to construct the entire function..
[12:12:00] <akshayrevankar> salman bhai.. any doubts :D
[12:12:21] <salman-bhai> no :p
[12:12:42] <akshayrevankar> ok cool...
[12:13:35] <akshayrevankar> so this is a list [1,2,3,4] can you tell me the most expanded way in which i can represent it in erlang ie.. composing it of a basic single sized list element..
[12:15:05] <salman-bhai> [4|[3 | [2 | [1 | [] ] ] ]]
[12:15:18] <salman-bhai> Did you mean this?
[12:15:39] <salman-bhai> The order should be reversed*
[12:15:40] <vilas_m> The order should be reverse right?
[12:15:51] <salman-bhai> Yeah vilas_m
[12:15:52] <akshayrevankar> yes dont you think @salman..
[12:15:56] <akshayrevankar> ya.. correct
[12:16:15] <akshayrevankar> [1|[2 | [3 | [4 | [] ] ] ]].
[12:16:50] <akshayrevankar> this is how the list [1,2,3,4]. would be represented.. does any1 have a doubt how it came.. i guess it was discussed in #session 2..
[12:17:14] <vilas_m> No Doubts.
[12:17:19] <m_gautham> no doubts
[12:17:20] <salman-bhai> no diubts
[12:17:21] <akshayrevankar> please have a look through it and keep revising.. the further concepts and this will heavily involve pattern matching and lists everywhere..
[12:17:23] <adarsh_h> nope
[12:17:30] <aditya> no
[12:17:36] <akshayrevankar> ok.. so lets continue..
[12:17:36] <salman-bhai> no*
[12:17:41] *** Joins: pratyushgr (dfb085e9@gateway/web/freenode/ip.223.176.133.233)
[12:18:22] <akshayrevankar> ah nice timing.. pratyush did u go through the log?
[12:18:35] <akshayrevankar> :P
[12:18:59] <akshayrevankar> ok.. our task: ot find the number of elements in a list..
[12:19:03] <akshayrevankar> to*
[12:19:22] <akshayrevankar> so we have the base case length([])->0;
[12:19:51] <akshayrevankar> so now we need to break the list [1,2,3,4] into its smaller elements..
[12:20:13] <akshayrevankar> how can we split the list into two lists, one with a single element and the rest into another
[12:20:16] <akshayrevankar> ?
[12:20:34] <salman-bhai> [] and [1,2,3,4] ?
[12:20:40] <aditya> [H|T]
[12:20:42] <vilas_m> The header and rest of the list [ 1 | L ]
[12:21:14] <akshayrevankar> ya correct..
[12:21:35] <akshayrevankar> a head and the rest or the tail and the rest..
[12:22:29] <akshayrevankar> so what will be the pattern matching applicable to extract the head and the tail given as an input to the function length
[12:22:53] <akshayrevankar> if i have length(input) , how can i get the head and tail BY PATTERN MATCHING?
[12:23:22] <vilas_m> Write a list as say [ _ | L ]. And find the length of L
[12:24:04] <akshayrevankar> ok can you write the function @vilas..?
[12:24:36] <vilas_m> length([ ] ) -> 0; length( [  _ | L ] ) -> length(L).
[12:24:46] *** Quits: adarsh_h (6ace890c@gateway/web/freenode/ip.106.206.137.12) (Quit: Page closed)
[12:24:51] <vilas_m> damn sorry 1 + length(L)
[12:25:01] <akshayrevankar> ahh. thats right
[12:25:08] <akshayrevankar> thats why i asked :D
[12:25:51] <akshayrevankar> I know its difficult for you guys to understand how to get the functions, but with more examples, you will get the trick to do it..
[12:26:27] <akshayrevankar> so our function is length([])->0; length([_|L])->1+length(L).
[12:26:32] <akshayrevankar> so lets trace this..
[12:26:47] <akshayrevankar> length([1,2,3,4]) = length([1 | [2,3,4])
[12:27:16] <akshayrevankar>                = 1 + length([2 | [3,4]])
[12:27:23] <akshayrevankar>                = 1 + 1 + length([3 | [4]])
[12:27:27] <akshayrevankar>                = 1 + 1 + 1 + length([4 | []])
[12:27:33] <akshayrevankar>                = 1 + 1 + 1 + 1 + length([])
[12:27:37] <akshayrevankar>                = 1 + 1 + 1 + 1 + 0
[12:27:41] <akshayrevankar>                = 1 + 1 + 1 + 1
[12:27:46] <akshayrevankar>                = 1 + 1 + 2
[12:27:50] <akshayrevankar>                = 1 + 3
[12:27:55] <akshayrevankar>                = 4
[12:28:22] <akshayrevankar> right? did u guys understand how the pattern matching n recursion worked?
[12:28:28] <salman-bhai> Yes.
[12:28:29] <aditya> yup!
[12:28:45] <vilas_m> Yes
[12:28:50] <akshayrevankar> others...
[12:29:07] <akshayrevankar> its very important to understand till this much..
[12:29:21] <akshayrevankar> we are 2/3rd done :)
[12:29:28] <m_gautham> yes but what will be export??
[12:29:40] <akshayrevankar> ya what will be the export..?
[12:29:58] <m_gautham> length/1 doesnt work
[12:30:05] <akshayrevankar> is it ?
[12:30:21] <vilas_m> length/1 should work right? One list as one element?
[12:30:30] <vilas_m> argument*
[12:30:31] <m_gautham> sorry it does
[12:31:09] <akshayrevankar> yes it does. :D
[12:31:40] <akshayrevankar> so now can anyone tell me what is the disadvantage of the above way of doing the recursion?
[12:32:33] <vilas_m> Order N for finding the length of a list?
[12:32:56] <akshayrevankar> ok.. do you have a lower order for doing it? o.O
[12:32:58] <vilas_m> Ok No :P Sorry
[12:33:15] <akshayrevankar> :D
[12:33:25] <vilas_m> Na. Was thinking in terms of log N lines :P
[12:33:35] <akshayrevankar> ok..
[12:34:02] <akshayrevankar> you very need to know the existence of all elements :D so it cant be lower... :P
[12:34:17] <vilas_m> Yea xD
[12:34:20] <akshayrevankar> so ya.. what could be the major disadvantage...
[12:34:49] <aditya> No idea!
[12:35:01] <akshayrevankar> so you can see that to get the final result you need to travel till the last recursive call and start returning all the values back.. right?
[12:35:15] <akshayrevankar> the initial 1 + length([2 | [3,4]]) wontget complete
[12:35:25] <akshayrevankar> till u reach the length([])
[12:36:10] <akshayrevankar> but you know that you can  do the 1+1 and then next stage the 2+1 and so on..
[12:36:55] <akshayrevankar> see the 1+1 computation wont happen, because the second line has to return (1+ length([3 | [4]]))..
[12:37:18] <akshayrevankar> it cant just say that.. for now you take the 1, and then i will send the rest for you to calculate later.. right? :D
[12:37:46] <akshayrevankar> a return means the computation in that part is done and value is completely returned..
[12:38:38] <akshayrevankar> did u understand that?
[12:38:42] <vilas_m> Yup
[12:39:31] <akshayrevankar> it looks above as if the 1 +1 and 1+ 1 + 1could be calculated.. but it cant as the the 1+ is bound to the next function call.. it has to be calculated and then only it can be returned..
[12:39:59] <akshayrevankar> so can you tell me which memory areas are gettings utilised in this process.?
[12:40:16] <akshayrevankar> getting*
[12:41:18] <akshayrevankar> ?
[12:41:52] <vilas_m> Heap?
[12:42:48] <akshayrevankar> an intelligent answer.. dont be so generic :P
[12:43:30] <akshayrevankar> anyone...
[12:44:26] <salman-bhai> No idea sir.
[12:44:50] <akshayrevankar> i guess the term "area" i used was a bit misleading..
[12:45:15] <akshayrevankar> ohk.. mainly the two things where we are utilising the memory is the temporary 1+ part
[12:45:24] <akshayrevankar> and the stack..
[12:45:33] <akshayrevankar> can anyone tell me where we are using the stack here?
[12:45:56] <aditya> function call?
[12:45:59] <salman-bhai> the function
[12:46:02] <salman-bhai> call
[12:46:10] <akshayrevankar> absolutely correct...
[12:46:29] <akshayrevankar> so you can see as N increases the function call stack becomes too huge...
[12:47:04] <akshayrevankar> and also we need to take care of the 1+ addition when it returns
[12:47:11] <akshayrevankar> so its a huge computation work right?
[12:47:26] <akshayrevankar> so thats where we inttroduce the concept of tail recursion..
[12:48:03] <akshayrevankar> so.. i will start of with the example so that its easier for you guys to understand..
[12:48:13] <akshayrevankar> we had length([])->0;
[12:48:27] <akshayrevankar> length([_|L])->1+length(L).
[12:48:38] <akshayrevankar> IN CASE OF TAIL RECURSION, we will have
[12:48:49] <akshayrevankar> tail_length(L) -> tail_length(L,0).
[12:49:04] <akshayrevankar> tail_length([], past) -> past;
[12:49:24] <akshayrevankar> tail_len([_|L], past) -> tail_len(L,past+1).
[12:49:46] <akshayrevankar> tail_length([_|L], past) -> tail_length(L,past+1).      ***correct the len to length
[12:50:07] <akshayrevankar> ok so now lets trace the function..
[12:50:42] <akshayrevankar> can someone write the first 2 trace for tail_length([1,2,3,4]).
